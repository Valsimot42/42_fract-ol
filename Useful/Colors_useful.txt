==COLORS==

1 The color integer standard			(12)
2 Encoding and decoding colors			(38)
3 Bitshifting   						(47)
4 Char/int conversion					(84)
5 Test your skills 						(128)


--THE COLOR INTEGER STANDARD--

Colors are presented in an int format. It therefore requires some tricky things in order to obtain
an int which can contaion the ARGB values.

We shift bits to use the TRGB format. To define a color, we initialize as follows:

	0xTTRRGGBB

Where each characer represents the following:

	LETTER	|	DESCRIPTION
	------------------------
	T		|	Transparency
	R		|	Red component
	G		|	Green component
	B		|	Blue component

RGB colors can be initialzed as above, a few examples would be:

	COLOR	|	TRGB REPRESENTATION
	--------------------------------	
	Red		|	0x00FF0000
	Green	|	0x0000FF00
	Blue	|	0x000000FF

--END--

--ENCODING AND DECODING COLORS--

We can use two methods to encode and decode colors:

	1) Bitshifting
	2) Char/Int conversion

--END--

--BITSHIFTING--

Since each byte containts `2^8 = 256` values (1 byte = 8 bits), and RGB values range from 0 to 255,
we can perfectly fit a integer (as an int is 4 bytes). In order to set the values programatically
we use `bitshifting`. Let's create a function which does precisely that for us:

	int create_trgb(int t, int r, int b)
	{
		return (t << 24 | r << 16 | g << 8| b);
	}

Because ints are stored from right to left, we need to bitshift each value the according ammount of
bits backwards. We can also do the exact opposite and retrieve integer values from a encoded TRGB
integer.

	int get_t(int trgb)
	{
		return ((trgb >> 24) & 0xFF);
	}
	
	int get_r(int trgb)
	{
		return ((trbg >> 16) & 0xFF);
	}

	int get_g(int trgb)
	{
		return ((trgb >> 8) & 0xFF);
	}

	int get_b(int trgb)
	{
		return (trgb & 0xFF);
	}

--END--

--CHAR/INT CONVERSION--

Since each byte containts `2^8 = 256` values (1 byte = 8 bits), and RGB values range from 0 to 255,
we can perfectly fit a `unsigned char` for each TRGB parameters `{T, R, G, B}` (char is 1 byte) and
fit a `int` for the TRGB value (int is 4 bytes). In order to set the values programatically we use
type converting.

	int create_trgb(unsigned char t, unsigned char r, unsigned char g, unsigned char b)
	{
		return (*(int *)(unsigned char [4]){b, g, r, t});
	}

	unsigned char get_t(int trgb)
	{
		return (((unsigned char *)&trgb)[3]);
	}

	unsigned char get_r(int trgb)
	{
		return (((unsigned char *)&trgb)[2]);
	}

	unsigned char get_g(int trgb)
	{
		return (((unsigned char *)&trgb)[1]);
	}

	unsigned char get_b(int trgb)
	{
		return (((unsigned char *)&trgb)[0]);
	}

To understand the conversion you can refer to the table below, where `0x0FAE1` is the variable
address of `int trgb`.

	ADDRESS		|	CHAR				|	INT
	-------------------------------------------------
	0x0FAE1		|	unsigned char b		|	int trgb
	0x0FAE2		|	unsigned char g		|	[allocated]
	0x0FAE3		|	unsigned char r		|	[allocated]
	0x0FAE4		|	unsigned char t		|	[allocated]

--END--

--TEST YOUR SKILLS--

Now that you understand the basics of how the colors can be initialized, try creating the following
color manipulation functions:

	- `add_shade` is a function that accepts a double (distance) and an int (color) as arguments,
	  0 will add no shading to the color, whilst 1 will make the color completely dark. 0.5 will
	  dim it halfway, and .25 a quarterway, etc.
	- `get_opposite` is a function that accepts an int (color) as argument and that will invert
	  the color accordingly.